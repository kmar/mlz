/*
   mini-LZ library (mlz)
   (c) Martin Sedlak 2016-2018

   Boost Software License - Version 1.0 - August 17th, 2003

   Permission is hereby granted, free of charge, to any person or organization
   obtaining a copy of the software and accompanying documentation covered by
   this license (the "Software") to use, reproduce, display, distribute,
   execute, and transmit the Software, and to prepare derivative works of the
   Software, and to permit third-parties to whom the Software is furnished to
   do so, all subject to the following:

   The copyright notices in the Software and this entire statement, including
   the above license grant, this restriction and the following disclaimer,
   must be included in all copies of the Software, in whole or in part, and
   all derivative works of the Software, unless such copies or derivative
   works are solely in the form of machine-executable object code generated by
   a source language processor.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
   SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
   FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
   DEALINGS IN THE SOFTWARE.
*/

#ifndef MLZ_THREAD_H
#define MLZ_THREAD_H

#if defined(MLZ_THREADS)

#include "mlz_common.h"

#ifdef __cplusplus
extern "C" {
#endif

/* mutex */
typedef void *mlz_mutex;

/* event (=mutex + condition variable) */
typedef void *mlz_event;

/* thread procedure */
typedef void (*mlz_thread_proc)(void *param);

/* thread */
typedef struct mlz_thread {
	void           *handle;
	mlz_thread_proc proc;
	void           *param;
} *mlz_thread;

/* returns MLZ_NULL on failure */
MLZ_API mlz_mutex mlz_mutex_create (void);
/* returns MLZ_FALSE on failure */
MLZ_API mlz_bool mlz_mutex_destroy(mlz_mutex mutex);
MLZ_API mlz_bool mlz_mutex_lock   (mlz_mutex mutex);
MLZ_API mlz_bool mlz_mutex_unlock (mlz_mutex mutex);

/* returns MLZ_NULL on failure */
MLZ_API mlz_event mlz_event_create (void);
/* returns MLZ_FALSE on failure */
MLZ_API mlz_bool  mlz_event_destroy(mlz_event event);
MLZ_API mlz_bool  mlz_event_reset  (mlz_event event);
MLZ_API mlz_bool  mlz_event_set    (mlz_event event);
MLZ_API mlz_bool  mlz_event_wait   (mlz_event event);

/* returns MLZ_NULL on failure */
MLZ_API mlz_thread mlz_thread_create(void);
/* returns MLZ_FALSE on failure */
MLZ_API mlz_bool mlz_thread_run(
	mlz_thread      thread,
	mlz_thread_proc proc,
	void           *param
);
MLZ_API mlz_bool mlz_thread_destroy (mlz_thread thread);
/* wait for thread to finish */
MLZ_API mlz_bool mlz_thread_join    (mlz_thread thread);

typedef void (*mlz_job_proc)(int thread, void *param);

typedef struct
{
	mlz_job_proc job;
	void        *param;
	int          idx;
} mlz_job;

struct mlz_jobs;

typedef struct
{
	struct mlz_jobs *jobs;
	mlz_job          job;
	mlz_thread       thread;
	mlz_event        event;
	mlz_bool         stop;
	mlz_bool         active;
} mlz_job_thread;

typedef struct mlz_jobs
{
	int            num_threads;
	int            active_threads;
	mlz_bool       running;
	mlz_mutex      mutex;
	mlz_event      queue_done_event;
	mlz_job_thread thread[1];
} *mlz_jobs;

/* returns MLZ_NULL on failure */
MLZ_API mlz_jobs mlz_jobs_create (int num_threads);
/* returns MLZ_FALSE on failure */
MLZ_API mlz_bool mlz_jobs_destroy(mlz_jobs jobs);
MLZ_API mlz_bool mlz_jobs_prepare_batch(mlz_jobs jobs, mlz_int num_threads);
MLZ_API mlz_bool mlz_jobs_enqueue(mlz_jobs jobs, mlz_job job);
MLZ_API mlz_bool mlz_jobs_wait   (mlz_jobs jobs);

#ifdef __cplusplus
}
#endif

/* MLZ_THREADS */
#endif

#endif
