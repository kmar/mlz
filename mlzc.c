/*
   mini-LZ library (mlz)
   (c) Martin Sedlak 2016-2018

   Boost Software License - Version 1.0 - August 17th, 2003

   Permission is hereby granted, free of charge, to any person or organization
   obtaining a copy of the software and accompanying documentation covered by
   this license (the "Software") to use, reproduce, display, distribute,
   execute, and transmit the Software, and to prepare derivative works of the
   Software, and to permit third-parties to whom the Software is furnished to
   do so, all subject to the following:

   The copyright notices in the Software and this entire statement, including
   the above license grant, this restriction and the following disclaimer,
   must be included in all copies of the Software, in whole or in part, and
   all derivative works of the Software, unless such copies or derivative
   works are solely in the form of machine-executable object code generated by
   a source language processor.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
   SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
   FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
   DEALINGS IN THE SOFTWARE.
*/

/* define this in your project to build this tool */
#ifdef MLZ_COMMANDLINE_TOOL

#ifdef _MSC_VER
#	define _CRT_SECURE_NO_WARNINGS
#endif

/* very simple command line tool, demonstrates streaming API */
/* FIXME: clean up                                           */

#include "mlz_stream_enc.h"
#include "mlz_stream_dec.h"
#include "mlz_enc.h"
#include "mlz_version.h"
#include "mlz_thread.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

static MLZ_CONST char *in_file  = MLZ_NULL;
static MLZ_CONST char *out_file = MLZ_NULL;
static int level                = MLZ_LEVEL_MAX;
static mlz_bool compress        = MLZ_TRUE;
static mlz_bool force           = MLZ_FALSE;
/* test archive */
static mlz_bool test            = MLZ_FALSE;
/* use independent blocks */
static mlz_bool independent     = MLZ_FALSE;
/* use compressed block checksum */
static mlz_bool block_checksum  = MLZ_FALSE;
static mlz_bool show_ver        = MLZ_FALSE;
static mlz_bool unsafe          = MLZ_FALSE;
static mlz_bool raw             = MLZ_FALSE;
static mlz_bool raw_mem         = MLZ_FALSE;
static mlz_int  block_size      = 65536;
#if defined(MLZ_THREADS)
static mlz_int  num_threads     = 1;
#endif

static char buffer[65536];

static int parse_args(int argc, char **argv)
{
	int i;
	for (i=1; i<argc; i++) {
		if (argv[i][0] != '-') {
			if (!in_file)
				in_file = argv[i];
			else if (!out_file)
				out_file = argv[i];
			else {
				(void)fprintf(stderr, "too many files\n");
				return 1;
			}
			continue;
		}
		/* assume arg */
		if (argv[i][1] >= '0' && argv[i][1] <= '9') {
			long alevel = strtol(argv[i]+1, MLZ_NULL, 10);
			level = alevel < 1 ? 1 : (alevel > MLZ_LEVEL_OPTIMAL ? MLZ_LEVEL_OPTIMAL : (mlz_int)alevel);
		} else if (strcmp(argv[i], "--best") == 0 || strcmp(argv[i], "--max") == 0) {
			level = MLZ_LEVEL_MAX;
		} else if (strcmp(argv[i], "--fastest") == 0) {
			level = MLZ_LEVEL_FASTEST;
		} else if (strcmp(argv[i], "-v") == 0 || strcmp(argv[i], "--version") == 0) {
			show_ver = MLZ_TRUE;
		} else if (strcmp(argv[i], "-u") == 0 || strcmp(argv[i], "--unsafe") == 0) {
			unsafe = MLZ_TRUE;
		} else if (strcmp(argv[i], "-r") == 0 || strcmp(argv[i], "--raw") == 0) {
			raw = MLZ_TRUE;
		} else if (strcmp(argv[i], "-rm") == 0 || strcmp(argv[i], "--raw-memory") == 0) {
			raw_mem = MLZ_TRUE;
		} else if (strcmp(argv[i], "-c") == 0 || strcmp(argv[i], "--compress") == 0) {
			compress = MLZ_TRUE;
		} else if (strcmp(argv[i], "-d") == 0 || strcmp(argv[i], "--decompress") == 0) {
			compress = MLZ_FALSE;
		} else if (strcmp(argv[i], "-f") == 0 || strcmp(argv[i], "--force") == 0) {
			force = MLZ_TRUE;
		} else if (strcmp(argv[i], "-t") == 0 || strcmp(argv[i], "--test") == 0) {
			test = MLZ_TRUE;
		} else if (strcmp(argv[i], "-bc") == 0 || strcmp(argv[i], "--block-checksum") == 0) {
			block_checksum = MLZ_TRUE;
		} else if (strcmp(argv[i], "-i") == 0 || strcmp(argv[i], "--independent") == 0) {
			independent = MLZ_TRUE;
		} else if (strcmp(argv[i], "-b") == 0 || strcmp(argv[i], "--block") == 0) {
			long ablock_size;
			if (i+1 >= argc) {
				(void)fprintf(stderr, "block size expects argument\n");
				return 2;
			}
			ablock_size = strtol(argv[++i], MLZ_NULL, 10);
			ablock_size *= 1024;
			if (ablock_size < MLZ_MIN_BLOCK_SIZE || ablock_size > MLZ_MAX_BLOCK_SIZE) {
				(void)fprintf(stderr, "invalid block size: %ld\n", ablock_size);
				return 2;
			}
			block_size = (mlz_int)ablock_size;
#if defined(MLZ_THREADS)
		} else if (strcmp(argv[i], "-T") == 0 || strcmp(argv[i], "--threads") == 0) {
			if (i+1 >= argc) {
				(void)fprintf(stderr, "threads expect argument\n");
				return 2;
			}
			num_threads = (mlz_int)strtol(argv[++i], MLZ_NULL, 10);
			if (num_threads < 1 || num_threads > MLZ_MAX_THREADS) {
				(void)fprintf(stderr, "invalid number of threads: %d\n", (int)num_threads);
				return 2;
			}
#endif
		} else {
			(void)fprintf(stderr, "invalid argument: `%s'\n", argv[i]);
			return 2;
		}
	}
	if (!in_file && test) {
		(void)fprintf(stderr, "please specify input file\n");
		return 3;
	}
	if (!out_file && !test) {
		(void)fprintf(stderr, "please specify both input and output file\n");
		return 3;
	}
	if (test)
		compress = MLZ_FALSE;
	return 0;
}

static void help(void)
{
	printf("usage: mlzc [args] <infile> <outfile>\n");
	printf("       -c or --compress   compress   in->out\n");
	printf("       -d or --decompress decompress in->out\n");
	printf("       -1 to -10         select compression level\n");
	printf("       --best or --max   maximum compression (default)\n");
	printf("       --fastest         fastest compression (hurts ratio a lot)\n");
	printf("       -11               very slow near-optimal parsing\n");
	printf("       -f or --force     force to overwrite outfile\n");
	printf("       -t or --test      test compressed infile\n");
	printf("       -b or --block <n> set block size in kb, default is 64\n");
	printf("       -bc or --block-checksum include compressed block checksum\n");
	printf("       -v or --version   show library version\n");
	printf("       -u or --unsafe    unsafe decompression\n");
#if defined(MLZ_THREADS)
	printf("       -T or --threads <n> set number of threads (1-%d)\n", (int)MLZ_MAX_THREADS);
#endif
	printf("       -i or --independent use independent blocks\n");
	printf("           when using independent blocks, it's recommended\n");
	printf("           to use block size of 128k or more\n");
	printf("       -r or --raw       don't use stream header\n");
	printf("       -rm or --raw-memory raw in memory compression\n");
}

#if defined(MLZ_THREADS)

static mlz_jobs jobs = MLZ_NULL;

static void init_jobs(void)
{
	if (num_threads > 1)
		jobs = mlz_jobs_create(num_threads-1);
}

static void destroy_jobs(void)
{
	(void)mlz_jobs_destroy(jobs);
}
#endif

static int out_of_memory(void)
{
	(void)fprintf(stderr, "out of memory\n");
	return 14;
}

static int raw_mem_compress(FILE *fin, FILE *fout)
{
	size_t insz, outsz, compsz;
	mlz_byte *inbuf;
	mlz_byte *outbuf;

	if (!fout)
		return 0;

	(void)fseek(fin, 0, SEEK_END);
	insz = (size_t)ftell(fin);
	(void)fseek(fin, 0, SEEK_SET);

	inbuf = (mlz_byte *)mlz_malloc(insz);

	if (!inbuf)
		return out_of_memory();

	if (fread(inbuf, insz, 1, fin) != 1) {
		mlz_free(inbuf);
		(void)fprintf(stderr, "failed to read input file\n");
		return 10;
	}

	outsz = insz + insz/8 + MLZ_CACHELINE_ALIGN;
	outbuf = (mlz_byte *)mlz_malloc(outsz);

	if (!outbuf) {
		mlz_free(inbuf);
		return out_of_memory();
	}

	compsz = mlz_compress_simple(outbuf, outsz, inbuf, insz, level);

	if (fwrite(outbuf, compsz, 1, fout) != 1) {
		mlz_free(inbuf);
		mlz_free(outbuf);
		(void)fprintf(stderr, "failed to write output file\n");
		return 7;
	}

	mlz_free(inbuf);
	mlz_free(outbuf);
	return 0;
}

static int raw_mem_decompress(FILE *fin, FILE *fout)
{
	(void)fin;
	(void)fout;
	(void)fprintf(stderr, "raw memory decompression not supported (don't know decomp_size)\n");
	return 13;
}

static int process(void)
{
	FILE *fin, *fout = MLZ_NULL;

	if (!test && !force) {
		FILE *ftest = fopen(out_file, "rb");
		if (ftest) {
			char buf[16] = {0};
			(void)fclose(ftest);
			printf("output file `%s' already exists.\noverwrite? (y/n)\n", out_file);
			if (!fgets(buf, sizeof(buf), stdin) || buf[0] != 'y') {
				printf("aborted\n");
				return 0;
			}
		}
	}

	fin = fopen(in_file, "rb");
	if (!fin) {
		(void)fprintf(stderr, "cannot open infile: `%s'\n", in_file);
		return 4;
	}

	if (!test) {
		fout = fopen(out_file, "wb");
		if (!fout) {
			(void)fclose(fin);
			(void)fprintf(stderr, "cannot create outfile: `%s'\n", out_file);
			return 5;
		}
	}

	if (compress) {
		mlz_out_stream   *outs;
		mlz_stream_params par  = mlz_default_stream_params;

		if (raw_mem) {
			int res = raw_mem_compress(fin, fout);
			MLZ_ASSERT(fout);
			(void)fclose(fout);
			(void)fclose(fin);
			return res;
		}

		par.handle             = fout;
		par.independent_blocks = independent;
		par.block_size         = block_size;
		par.close_func         = MLZ_NULL;
#if defined(MLZ_THREADS)
		par.jobs               = jobs;
#endif
		if (block_checksum)
			par.block_checksum = mlz_adler32_simple;
		if (raw)
			par.use_header = MLZ_FALSE;

		outs = mlz_out_stream_open(&par, level);
		if (!outs) {
			(void)fclose(fin);
			if (fout)
				(void)fclose(fout);
			(void)fprintf(stderr, "couldn't create out stream\n");
			return 6;
		}
		for (;;) {
			size_t nread = fread(buffer, 1, sizeof(buffer), fin);
			if (!nread)
				break;
			if (mlz_stream_write(outs, buffer, nread) != (mlz_intptr)nread) {
				(void)mlz_out_stream_close(outs);
				(void)fclose(fin);
				if (fout)
					(void)fclose(fout);
				(void)fprintf(stderr, "failed to write out stream\n");
				return 7;
			}
		}
		if (!mlz_out_stream_close(outs)) {
			(void)fclose(fin);
			if (fout)
				(void)fclose(fout);
			(void)fprintf(stderr, "failed to close out stream\n");
			return 8;
		}
	} else {
		/* decompress */
		mlz_in_stream    *ins;
		mlz_stream_params par  = mlz_default_stream_params;

		if (raw_mem) {
			int res = raw_mem_decompress(fin, fout);
			if (fout)
				(void)fclose(fout);
			(void)fclose(fin);
			return res;
		}

		par.handle             = fin;
		par.independent_blocks = independent;
		par.block_size         = block_size;
		par.unsafe             = unsafe;
		par.close_func         = MLZ_NULL;
		if (block_checksum)
			par.block_checksum = mlz_adler32_simple;
		if (raw)
			par.use_header     = MLZ_FALSE;
#if defined(MLZ_THREADS)
		par.jobs               = jobs;
#endif

		ins = mlz_in_stream_open(&par);
		if (!ins) {
			(void)fclose(fin);
			if (fout)
				(void)fclose(fout);
			(void)fprintf(stderr, "couldn't create/open in stream\n");
			return 9;
		}
		for (;;) {
			mlz_intptr nread = mlz_stream_read(ins, buffer, sizeof(buffer));
			if (nread < 0) {
				(void)mlz_in_stream_close(ins);
				(void)fclose(fin);
				if (fout)
					(void)fclose(fout);
				(void)fprintf(stderr, "failed to read in stream\n");
				return 10;
			}
			if (!nread)
				break;
			if (!test && fout && (mlz_intptr)fwrite(buffer, 1, nread, fout) != nread) {
				(void)mlz_in_stream_close(ins);
				(void)fclose(fin);
				if (fout)
					(void)fclose(fout);
				(void)fprintf(stderr, "failed to write out file\n");
				return 11;
			}
		}
		if (!mlz_in_stream_close(ins)) {
			(void)fclose(fin);
			if (fout)
				(void)fclose(fout);
			(void)fprintf(stderr, "failed to close in stream\n");
			return 12;
		}
	}
	if (fout)
		(void)fclose(fout);
	(void)fclose(fin);
	return 0;
}

int main(int argc, char **argv)
{
	int res;
	int err = parse_args(argc, argv);
	if (show_ver)
		printf("mlz v" MLZ_VERSION "\n");
	if (err) {
		help();
		return err;
	}

#if defined(MLZ_THREADS)
	init_jobs();
	res = process();
	destroy_jobs();
#else
	res = process();
#endif

	return res;
}

#endif
